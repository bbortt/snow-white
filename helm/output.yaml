---
# Source: snow-white/charts/influxdb/templates/networkpolicy.yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: release-name-influxdb
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: influxdb
    app.kubernetes.io/version: 3.4.1
    helm.sh/chart: influxdb-7.1.20
    app.kubernetes.io/part-of: influxdb
    app.kubernetes.io/component: influxdb
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: influxdb
      app.kubernetes.io/part-of: influxdb
      app.kubernetes.io/component: influxdb
  policyTypes:
    - Ingress
    - Egress
  egress:
    - {}
  ingress:
    # Allow inbound connections
    - ports:
        - port: 8181
          protocol: TCP
---
# Source: snow-white/charts/kafka/templates/controller-eligible/networkpolicy.yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: release-name-kafka-controller
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 4.0.0
    helm.sh/chart: kafka-32.4.3
    app.kubernetes.io/component: controller-eligible
    app.kubernetes.io/part-of: kafka
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: kafka
      app.kubernetes.io/component: controller-eligible
      app.kubernetes.io/part-of: kafka
  policyTypes:
    - Ingress
    - Egress
  egress:
    - {}
  ingress:
    # Allow client connections
    - ports:
        - port: 9093
        - port: 9092
        - port: 9094
---
# Source: snow-white/charts/postgresql/templates/primary/networkpolicy.yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: release-name-postgresql-primary
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 17.6.0
    helm.sh/chart: postgresql-16.7.27
    app.kubernetes.io/component: primary
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/component: primary
  policyTypes:
    - Ingress
    - Egress
  egress:
    - {}
  ingress:
    - ports:
        - port: 5432
---
# Source: snow-white/charts/postgresql/templates/read/networkpolicy.yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: release-name-postgresql-read
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 17.6.0
    helm.sh/chart: postgresql-16.7.27
    app.kubernetes.io/component: read
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/component: read
  policyTypes:
    - Ingress
    - Egress
  egress:
    - {}
  ingress:
    - ports:
        - port: 5432
---
# Source: snow-white/charts/redis/templates/networkpolicy.yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: release-name-redis
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis
    app.kubernetes.io/version: 8.2.1
    helm.sh/chart: redis-22.0.7
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: redis
  policyTypes:
    - Ingress
    - Egress
  egress:
    - {}
  ingress:
    # Allow inbound connections
    - ports:
        - port: 6379
---
# Source: snow-white/charts/influxdb/templates/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: release-name-influxdb
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: influxdb
    app.kubernetes.io/version: 3.4.1
    helm.sh/chart: influxdb-7.1.20
    app.kubernetes.io/part-of: influxdb
    app.kubernetes.io/component: influxdb
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: influxdb
      app.kubernetes.io/part-of: influxdb
      app.kubernetes.io/component: influxdb
---
# Source: snow-white/charts/kafka/templates/broker/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: release-name-kafka-broker
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 4.0.0
    helm.sh/chart: kafka-32.4.3
    app.kubernetes.io/component: broker
    app.kubernetes.io/part-of: kafka
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: kafka
      app.kubernetes.io/component: broker
      app.kubernetes.io/part-of: kafka
---
# Source: snow-white/charts/kafka/templates/controller-eligible/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: release-name-kafka-controller
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 4.0.0
    helm.sh/chart: kafka-32.4.3
    app.kubernetes.io/component: controller-eligible
    app.kubernetes.io/part-of: kafka
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: kafka
      app.kubernetes.io/component: controller-eligible
      app.kubernetes.io/part-of: kafka
---
# Source: snow-white/charts/postgresql/templates/primary/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: release-name-postgresql-primary
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 17.6.0
    helm.sh/chart: postgresql-16.7.27
    app.kubernetes.io/component: primary
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/component: primary
---
# Source: snow-white/charts/postgresql/templates/read/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: release-name-postgresql-read
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 17.6.0
    helm.sh/chart: postgresql-16.7.27
    app.kubernetes.io/component: read
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/component: read
---
# Source: snow-white/charts/redis/templates/master/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: release-name-redis-master
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis
    app.kubernetes.io/version: 8.2.1
    helm.sh/chart: redis-22.0.7
    app.kubernetes.io/component: master
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: redis
      app.kubernetes.io/component: master
---
# Source: snow-white/charts/redis/templates/replicas/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: release-name-redis-replicas
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis
    app.kubernetes.io/version: 8.2.1
    helm.sh/chart: redis-22.0.7
    app.kubernetes.io/component: replica
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: redis
      app.kubernetes.io/component: replica
---
# Source: snow-white/charts/influxdb/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: release-name-influxdb
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: influxdb
    app.kubernetes.io/version: 3.4.1
    helm.sh/chart: influxdb-7.1.20
    app.kubernetes.io/part-of: influxdb
    app.kubernetes.io/component: influxdb
automountServiceAccountToken: false
---
# Source: snow-white/charts/kafka/templates/provisioning/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: release-name-kafka-provisioning
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 4.0.0
    helm.sh/chart: kafka-32.4.3
automountServiceAccountToken: false
---
# Source: snow-white/charts/kafka/templates/rbac/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: release-name-kafka
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 4.0.0
    helm.sh/chart: kafka-32.4.3
    app.kubernetes.io/component: kafka
automountServiceAccountToken: false
---
# Source: snow-white/charts/postgresql/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: release-name-postgresql
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 17.6.0
    helm.sh/chart: postgresql-16.7.27
automountServiceAccountToken: false
---
# Source: snow-white/charts/redis/templates/master/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
automountServiceAccountToken: false
metadata:
  name: release-name-redis-master
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis
    app.kubernetes.io/version: 8.2.1
    helm.sh/chart: redis-22.0.7
---
# Source: snow-white/charts/redis/templates/replicas/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
automountServiceAccountToken: false
metadata:
  name: release-name-redis-replica
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis
    app.kubernetes.io/version: 8.2.1
    helm.sh/chart: redis-22.0.7
---
# Source: snow-white/charts/kafka/templates/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: release-name-kafka-user-passwords
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 4.0.0
    helm.sh/chart: kafka-32.4.3
type: Opaque
data:
  client-passwords: 'TlRobk9lSlE0Qw=='
  system-user-password: 'TlRobk9lSlE0Qw=='
  inter-broker-password: 'TjVwSlNDcXZQeA=='
  controller-password: 'WnFzQVlLRzh1SA=='
---
# Source: snow-white/charts/kafka/templates/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: release-name-kafka-kraft
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 4.0.0
    helm.sh/chart: kafka-32.4.3
type: Opaque
data:
  cluster-id: 'OG1lVG9RT25QTHVJOVRNVmJUQ0F4QQ=='
  controller-0-id: 'NXJHZENrVXY0dHNnSXUwTjZWelZlUQ=='
  controller-1-id: 'akd3WkFiNE1scEhhOTZGSHRsTDd6bA=='
  controller-2-id: 'cG5YeDR6TXBDYktIQ29YazZ2QlhiOQ=='
---
# Source: snow-white/charts/postgresql/templates/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: release-name-postgresql
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 17.6.0
    helm.sh/chart: postgresql-16.7.27
type: Opaque
data:
  postgres-password: 'RUdLVFZrM3NFWQ=='
  replication-password: 'YXZGQlloR3FmOA=='
  # We don't auto-generate LDAP password when it's not provided as we do for other passwords
---
# Source: snow-white/charts/redis/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: release-name-redis
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis
    app.kubernetes.io/version: 8.2.1
    helm.sh/chart: redis-22.0.7
type: Opaque
data:
  redis-password: 'QnA3bTVkNGJsNw=='
---
# Source: snow-white/charts/kafka/templates/controller-eligible/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: release-name-kafka-controller-configuration
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 4.0.0
    helm.sh/chart: kafka-32.4.3
    app.kubernetes.io/component: controller-eligible
    app.kubernetes.io/part-of: kafka
data:
  server.properties: |-
    advertised.listeners=CLIENT://advertised-address-placeholder:9092,INTERNAL://advertised-address-placeholder:9094
    controller.listener.names=CONTROLLER
    controller.quorum.bootstrap.servers=release-name-kafka-controller-0.release-name-kafka-controller-headless.snow-white.svc.cluster.local:9093,release-name-kafka-controller-1.release-name-kafka-controller-headless.snow-white.svc.cluster.local:9093,release-name-kafka-controller-2.release-name-kafka-controller-headless.snow-white.svc.cluster.local:9093
    inter.broker.listener.name=INTERNAL
    listener.name.client.plain.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required user_user1="password-placeholder-0";
    listener.name.client.scram-sha-256.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required;
    listener.name.client.scram-sha-512.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required;
    listener.name.controller.plain.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="controller_user" password="controller-password-placeholder" user_controller_user="controller-password-placeholder" user_user1="password-placeholder-0";
    listener.name.controller.scram-sha-256.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username="controller_user" password="controller-password-placeholder";
    listener.name.controller.scram-sha-512.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username="controller_user" password="controller-password-placeholder";
    listener.name.internal.plain.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="inter_broker_user" password="interbroker-password-placeholder" user_inter_broker_user="interbroker-password-placeholder" user_user1="password-placeholder-0";
    listener.name.internal.scram-sha-256.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username="inter_broker_user" password="interbroker-password-placeholder";
    listener.name.internal.scram-sha-512.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username="inter_broker_user" password="interbroker-password-placeholder";
    listener.security.protocol.map=CONTROLLER:SASL_PLAINTEXT,CLIENT:SASL_PLAINTEXT,INTERNAL:SASL_PLAINTEXT
    listeners=CLIENT://:9092,INTERNAL://:9094,CONTROLLER://:9093
    log.dir=/bitnami/kafka/data
    logs.dir=/opt/bitnami/kafka/logs
    process.roles=controller,broker
    sasl.enabled.mechanisms=PLAIN,SCRAM-SHA-256,SCRAM-SHA-512
    sasl.mechanism.controller.protocol=PLAIN
    sasl.mechanism.inter.broker.protocol=PLAIN
---
# Source: snow-white/charts/redis/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: release-name-redis-configuration
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis
    app.kubernetes.io/version: 8.2.1
    helm.sh/chart: redis-22.0.7
data:
  redis.conf: |-
    # User-supplied common configuration:
    # Enable AOF https://redis.io/topics/persistence#append-only-file
    appendonly yes
    # Disable RDB persistence, AOF persistence already enabled.
    save ""
    # End of common configuration
  master.conf: |-
    dir /data
    # User-supplied master configuration:
    rename-command FLUSHDB ""
    rename-command FLUSHALL ""
    # End of master configuration
  replica.conf: |-
    dir /data
    # User-supplied replica configuration:
    rename-command FLUSHDB ""
    rename-command FLUSHALL ""
    # End of replica configuration
  users.acl: |-
---
# Source: snow-white/charts/redis/templates/health-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: release-name-redis-health
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis
    app.kubernetes.io/version: 8.2.1
    helm.sh/chart: redis-22.0.7
data:
  ping_readiness_local.sh: |-
    #!/bin/bash

    [[ -f $REDIS_PASSWORD_FILE ]] && export REDIS_PASSWORD="$(< "${REDIS_PASSWORD_FILE}")"
    [[ -n "$REDIS_PASSWORD" ]] && export REDISCLI_AUTH="$REDIS_PASSWORD"
    response=$(
      timeout -s 15 $1 \
      redis-cli \
        -h localhost \
        -p $REDIS_PORT \
        ping
    )
    if [ "$?" -eq "124" ]; then
      echo "Timed out"
      exit 1
    fi
    if [ "$response" != "PONG" ]; then
      echo "$response"
      exit 1
    fi
  ping_liveness_local.sh: |-
    #!/bin/bash

    [[ -f $REDIS_PASSWORD_FILE ]] && export REDIS_PASSWORD="$(< "${REDIS_PASSWORD_FILE}")"
    [[ -n "$REDIS_PASSWORD" ]] && export REDISCLI_AUTH="$REDIS_PASSWORD"
    response=$(
      timeout -s 15 $1 \
      redis-cli \
        -h localhost \
        -p $REDIS_PORT \
        ping
    )
    if [ "$?" -eq "124" ]; then
      echo "Timed out"
      exit 1
    fi
    responseFirstWord=$(echo $response | head -n1 | awk '{print $1;}')
    if [ "$response" != "PONG" ] && [ "$responseFirstWord" != "LOADING" ] && [ "$responseFirstWord" != "MASTERDOWN" ]; then
      echo "$response"
      exit 1
    fi
  ping_readiness_master.sh: |-
    #!/bin/bash

    [[ -f $REDIS_MASTER_PASSWORD_FILE ]] && export REDIS_MASTER_PASSWORD="$(< "${REDIS_MASTER_PASSWORD_FILE}")"
    [[ -n "$REDIS_MASTER_PASSWORD" ]] && export REDISCLI_AUTH="$REDIS_MASTER_PASSWORD"
    response=$(
      timeout -s 15 $1 \
      redis-cli \
        -h $REDIS_MASTER_HOST \
        -p $REDIS_MASTER_PORT_NUMBER \
        ping
    )
    if [ "$?" -eq "124" ]; then
      echo "Timed out"
      exit 1
    fi
    if [ "$response" != "PONG" ]; then
      echo "$response"
      exit 1
    fi
  ping_liveness_master.sh: |-
    #!/bin/bash

    [[ -f $REDIS_MASTER_PASSWORD_FILE ]] && export REDIS_MASTER_PASSWORD="$(< "${REDIS_MASTER_PASSWORD_FILE}")"
    [[ -n "$REDIS_MASTER_PASSWORD" ]] && export REDISCLI_AUTH="$REDIS_MASTER_PASSWORD"
    response=$(
      timeout -s 15 $1 \
      redis-cli \
        -h $REDIS_MASTER_HOST \
        -p $REDIS_MASTER_PORT_NUMBER \
        ping
    )
    if [ "$?" -eq "124" ]; then
      echo "Timed out"
      exit 1
    fi
    responseFirstWord=$(echo $response | head -n1 | awk '{print $1;}')
    if [ "$response" != "PONG" ] && [ "$responseFirstWord" != "LOADING" ]; then
      echo "$response"
      exit 1
    fi
  ping_readiness_local_and_master.sh: |-
    script_dir="$(dirname "$0")"
    exit_status=0
    "$script_dir/ping_readiness_local.sh" $1 || exit_status=$?
    "$script_dir/ping_readiness_master.sh" $1 || exit_status=$?
    exit $exit_status
  ping_liveness_local_and_master.sh: |-
    script_dir="$(dirname "$0")"
    exit_status=0
    "$script_dir/ping_liveness_local.sh" $1 || exit_status=$?
    "$script_dir/ping_liveness_master.sh" $1 || exit_status=$?
    exit $exit_status
---
# Source: snow-white/charts/redis/templates/scripts-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: release-name-redis-scripts
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis
    app.kubernetes.io/version: 8.2.1
    helm.sh/chart: redis-22.0.7
data:
  start-master.sh: |
    #!/bin/bash

    [[ -f $REDIS_PASSWORD_FILE ]] && export REDIS_PASSWORD="$(< "${REDIS_PASSWORD_FILE}")"
    if [[ -f /opt/bitnami/redis/mounted-etc/master.conf ]];then
        cp /opt/bitnami/redis/mounted-etc/master.conf /opt/bitnami/redis/etc/master.conf
    fi
    if [[ -f /opt/bitnami/redis/mounted-etc/redis.conf ]];then
        cp /opt/bitnami/redis/mounted-etc/redis.conf /opt/bitnami/redis/etc/redis.conf
    fi
    if [[ -f /opt/bitnami/redis/mounted-etc/users.acl ]];then
        cp /opt/bitnami/redis/mounted-etc/users.acl /opt/bitnami/redis/etc/users.acl
    fi
    ARGS=("--port" "${REDIS_PORT}")
    ARGS+=("--requirepass" "${REDIS_PASSWORD}")
    ARGS+=("--masterauth" "${REDIS_PASSWORD}")
    ARGS+=("--include" "/opt/bitnami/redis/etc/redis.conf")
    ARGS+=("--include" "/opt/bitnami/redis/etc/master.conf")
    exec redis-server "${ARGS[@]}"
  start-replica.sh: |
    #!/bin/bash

    get_port() {
        hostname="$1"
        type="$2"

        port_var=$(echo "${hostname^^}_SERVICE_PORT_$type" | sed "s/-/_/g")
        port=${!port_var}

        if [ -z "$port" ]; then
            case $type in
                "SENTINEL")
                    echo 26379
                    ;;
                "REDIS")
                    echo 6379
                    ;;
            esac
        else
            echo $port
        fi
    }

    get_full_hostname() {
        hostname="$1"
        full_hostname="${hostname}.${HEADLESS_SERVICE}"
        echo "${full_hostname}"
    }

    REDISPORT=$(get_port "$HOSTNAME" "REDIS")
    HEADLESS_SERVICE="release-name-redis-headless.snow-white.svc.cluster.local"

    [[ -f $REDIS_PASSWORD_FILE ]] && export REDIS_PASSWORD="$(< "${REDIS_PASSWORD_FILE}")"
    [[ -f $REDIS_MASTER_PASSWORD_FILE ]] && export REDIS_MASTER_PASSWORD="$(< "${REDIS_MASTER_PASSWORD_FILE}")"
    if [[ -f /opt/bitnami/redis/mounted-etc/replica.conf ]];then
        cp /opt/bitnami/redis/mounted-etc/replica.conf /opt/bitnami/redis/etc/replica.conf
    fi
    if [[ -f /opt/bitnami/redis/mounted-etc/redis.conf ]];then
        cp /opt/bitnami/redis/mounted-etc/redis.conf /opt/bitnami/redis/etc/redis.conf
    fi
    if [[ -f /opt/bitnami/redis/mounted-etc/users.acl ]];then
        cp /opt/bitnami/redis/mounted-etc/users.acl /opt/bitnami/redis/etc/users.acl
    fi

    echo "" >> /opt/bitnami/redis/etc/replica.conf
    echo "replica-announce-port $REDISPORT" >> /opt/bitnami/redis/etc/replica.conf
    echo "replica-announce-ip $(get_full_hostname "$HOSTNAME")" >> /opt/bitnami/redis/etc/replica.conf
    ARGS=("--port" "${REDIS_PORT}")
    ARGS+=("--replicaof" "${REDIS_MASTER_HOST}" "${REDIS_MASTER_PORT_NUMBER}")
    ARGS+=("--requirepass" "${REDIS_PASSWORD}")
    ARGS+=("--masterauth" "${REDIS_MASTER_PASSWORD}")
    ARGS+=("--include" "/opt/bitnami/redis/etc/redis.conf")
    ARGS+=("--include" "/opt/bitnami/redis/etc/replica.conf")
    exec redis-server "${ARGS[@]}"
---
# Source: snow-white/charts/influxdb/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-influxdb
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: influxdb
    app.kubernetes.io/version: 3.4.1
    helm.sh/chart: influxdb-7.1.20
    app.kubernetes.io/part-of: influxdb
    app.kubernetes.io/component: influxdb
  annotations: {}
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
    - port: 8181
      targetPort: http
      protocol: TCP
      name: http
      nodePort: null
  selector:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/name: influxdb
    app.kubernetes.io/part-of: influxdb
    app.kubernetes.io/component: influxdb
---
# Source: snow-white/charts/kafka/templates/controller-eligible/svc-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-kafka-controller-headless
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 4.0.0
    helm.sh/chart: kafka-32.4.3
    app.kubernetes.io/component: controller-eligible
    app.kubernetes.io/part-of: kafka
spec:
  type: ClusterIP
  clusterIP: None
  publishNotReadyAddresses: true
  ports:
    - name: tcp-interbroker
      port: 9094
      protocol: TCP
      targetPort: interbroker
    - name: tcp-client
      port: 9092
      protocol: TCP
      targetPort: client
    - name: tcp-controller
      protocol: TCP
      port: 9093
      targetPort: controller
  selector:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/name: kafka
    app.kubernetes.io/component: controller-eligible
    app.kubernetes.io/part-of: kafka
---
# Source: snow-white/charts/kafka/templates/svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-kafka
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 4.0.0
    helm.sh/chart: kafka-32.4.3
    app.kubernetes.io/component: kafka
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
    - name: tcp-client
      port: 9092
      protocol: TCP
      targetPort: client
      nodePort: null
  selector:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/name: kafka
    app.kubernetes.io/part-of: kafka
---
# Source: snow-white/charts/postgresql/templates/primary/svc-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-postgresql-primary-hl
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 17.6.0
    helm.sh/chart: postgresql-16.7.27
    app.kubernetes.io/component: primary
  annotations:
spec:
  type: ClusterIP
  clusterIP: None
  # We want all pods in the StatefulSet to have their addresses published for
  # the sake of the other Postgresql pods even before they're ready, since they
  # have to be able to talk to each other in order to become ready.
  publishNotReadyAddresses: true
  ports:
    - name: tcp-postgresql
      port: 5432
      targetPort: tcp-postgresql
  selector:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/component: primary
---
# Source: snow-white/charts/postgresql/templates/primary/svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-postgresql-primary
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 17.6.0
    helm.sh/chart: postgresql-16.7.27
    app.kubernetes.io/component: primary
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
    - name: tcp-postgresql
      port: 5432
      targetPort: tcp-postgresql
      nodePort: null
  selector:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/component: primary
---
# Source: snow-white/charts/postgresql/templates/read/svc-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-postgresql-read-hl
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 17.6.0
    helm.sh/chart: postgresql-16.7.27
    app.kubernetes.io/component: read
  annotations:
spec:
  type: ClusterIP
  clusterIP: None
  # We want all pods in the StatefulSet to have their addresses published for
  # the sake of the other Postgresql pods even before they're ready, since they
  # have to be able to talk to each other in order to become ready.
  publishNotReadyAddresses: true
  ports:
    - name: tcp-postgresql
      port: 5432
      targetPort: tcp-postgresql
  selector:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/component: read
---
# Source: snow-white/charts/postgresql/templates/read/svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-postgresql-read
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 17.6.0
    helm.sh/chart: postgresql-16.7.27
    app.kubernetes.io/component: read
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
    - name: tcp-postgresql
      port: 5432
      targetPort: tcp-postgresql
      nodePort: null
  selector:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/component: read
---
# Source: snow-white/charts/redis/templates/headless-svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-redis-headless
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis
    app.kubernetes.io/version: 8.2.1
    helm.sh/chart: redis-22.0.7
spec:
  type: ClusterIP
  clusterIP: None
  ports:
    - name: tcp-redis
      port: 6379
      targetPort: redis
  selector:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/name: redis
---
# Source: snow-white/charts/redis/templates/master/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-redis-master
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis
    app.kubernetes.io/version: 8.2.1
    helm.sh/chart: redis-22.0.7
    app.kubernetes.io/component: master
spec:
  type: ClusterIP
  internalTrafficPolicy: Cluster
  sessionAffinity: None
  ports:
    - name: tcp-redis
      port: 6379
      targetPort: redis
      nodePort: null
  selector:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/name: redis
    app.kubernetes.io/component: master
---
# Source: snow-white/charts/redis/templates/replicas/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-redis-replicas
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis
    app.kubernetes.io/version: 8.2.1
    helm.sh/chart: redis-22.0.7
    app.kubernetes.io/component: replica
spec:
  type: ClusterIP
  internalTrafficPolicy: Cluster
  sessionAffinity: None
  ports:
    - name: tcp-redis
      port: 6379
      targetPort: redis
      nodePort: null
  selector:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/name: redis
    app.kubernetes.io/component: replica
---
# Source: snow-white/templates/api-gateway.yaml
apiVersion: v1
kind: Service
metadata:
  name: snow-white-release-name-api-gateway
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/version: v1.0.0-ci.0
    helm.sh/chart: snow-white
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/name: api-gateway
    app.kubernetes.io/part-of: snow-white
spec:
  type: ClusterIP
  selector:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/name: api-gateway
    app.kubernetes.io/part-of: snow-white
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: http
---
# Source: snow-white/charts/influxdb/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: release-name-influxdb
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: influxdb
    app.kubernetes.io/version: 3.4.1
    helm.sh/chart: influxdb-7.1.20
    app.kubernetes.io/part-of: influxdb
    app.kubernetes.io/component: influxdb
spec:
  revisionHistoryLimit: 10
  strategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: influxdb
      app.kubernetes.io/part-of: influxdb
      app.kubernetes.io/component: influxdb
  template:
    metadata:
      annotations:
      labels:
        app.kubernetes.io/instance: release-name
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: influxdb
        app.kubernetes.io/version: 3.4.1
        helm.sh/chart: influxdb-7.1.20
        app.kubernetes.io/part-of: influxdb
        app.kubernetes.io/component: influxdb
    spec:
      affinity:
        podAffinity:

        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/instance: release-name
                    app.kubernetes.io/name: influxdb
                    app.kubernetes.io/component: influxdb
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:

      priorityClassName: ''
      securityContext:
        fsGroup: 1001
        fsGroupChangePolicy: Always
        supplementalGroups: []
        sysctls: []
      serviceAccountName: release-name-influxdb
      initContainers:
      containers:
        - name: influxdb
          image: docker.io/bitnami/influxdb:3.4.1-debian-12-r0
          imagePullPolicy: 'IfNotPresent'
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            privileged: false
            readOnlyRootFilesystem: true
            runAsGroup: 1001
            runAsNonRoot: true
            runAsUser: 1001
            seLinuxOptions: {}
            seccompProfile:
              type: RuntimeDefault
          env:
            - name: BITNAMI_DEBUG
              value: 'false'
            - name: INFLUXDB_OBJECT_STORE
              value: 'memory'
            - name: INFLUXDB_HTTP_PORT_NUMBER
              value: '8181'
            - name: INFLUXDB_HTTP_AUTH_ENABLED
              value: 'true'
            - name: INFLUXDB_NODE_ID
              value: '0'
          ports:
            - name: http
              containerPort: 8181
              protocol: TCP
          livenessProbe:
            failureThreshold: 3
            initialDelaySeconds: 10
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
            tcpSocket:
              port: http
          readinessProbe:
            failureThreshold: 3
            initialDelaySeconds: 10
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
            tcpSocket:
              port: http
          resources:
            limits:
              cpu: 750m
              ephemeral-storage: 2Gi
              memory: 768Mi
            requests:
              cpu: 500m
              ephemeral-storage: 50Mi
              memory: 512Mi
          volumeMounts:
            - name: empty-dir
              mountPath: /tmp
              subPath: tmp-dir
      volumes:
        - name: empty-dir
          emptyDir: {}
---
# Source: snow-white/templates/api-gateway.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: snow-white-release-name-api-gateway
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/version: v1.0.0-ci.0
    helm.sh/chart: snow-white
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/name: api-gateway
    app.kubernetes.io/part-of: snow-white
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 0
      maxUnavailable: 1
  revisionHistoryLimit: 3
  selector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: api-gateway
      app.kubernetes.io/part-of: snow-white
  template:
    metadata:
      labels:
        app.kubernetes.io/instance: release-name
        app.kubernetes.io/name: api-gateway
        app.kubernetes.io/part-of: snow-white
    spec:
      securityContext:
        fsGroup: 101
      containers:
        - name: snow-white
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            runAsUser: 100
            runAsGroup: 101
          image: 'ghrc.io/bbortt/snow-white/api-gateway:v1.0.0-ci.0'
          imagePullPolicy: Always
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
            - name: actuator
              containerPort: 8080
              protocol: TCP
          resources:
            limits:
              ephemeral-storage: 0Gi
              memory: 0.5Gi
            requests:
              cpu: '0.5'
              ephemeral-storage: 0Mi
              memory: 0.5Gi
          livenessProbe:
            failureThreshold: 3
            httpGet:
              path: /api/manage/health
              port: actuator
              scheme: HTTP
            initialDelaySeconds: 45
            periodSeconds: 15
            successThreshold: 1
            timeoutSeconds: 5
          readinessProbe:
            failureThreshold: 12
            httpGet:
              path: /
              port: http
              scheme: HTTP
            initialDelaySeconds: 10
            periodSeconds: 5
            successThreshold: 1
            timeoutSeconds: 2
---
# Source: snow-white/charts/kafka/templates/controller-eligible/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: release-name-kafka-controller
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: kafka
    app.kubernetes.io/version: 4.0.0
    helm.sh/chart: kafka-32.4.3
    app.kubernetes.io/component: controller-eligible
    app.kubernetes.io/part-of: kafka
spec:
  podManagementPolicy: Parallel
  replicas: 3
  selector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: kafka
      app.kubernetes.io/component: controller-eligible
      app.kubernetes.io/part-of: kafka
  serviceName: release-name-kafka-controller-headless
  updateStrategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app.kubernetes.io/instance: release-name
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: kafka
        app.kubernetes.io/version: 4.0.0
        helm.sh/chart: kafka-32.4.3
        app.kubernetes.io/component: controller-eligible
        app.kubernetes.io/part-of: kafka
      annotations:
        checksum/configuration: ab6371424f5ae540c3d01a0e88159000d7d4406a8cd8b731d6c289976184c90d
        checksum/secret: b50e0e6bc7fcb45ae5af03dbf43f95f6026cb3de179fc0bb2f8c36ffacebe273
    spec:
      automountServiceAccountToken: false
      hostNetwork: false
      hostIPC: false
      affinity:
        podAffinity:

        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/instance: release-name
                    app.kubernetes.io/name: kafka
                    app.kubernetes.io/component: controller-eligible
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:

      securityContext:
        fsGroup: 1001
        fsGroupChangePolicy: Always
        seccompProfile:
          type: RuntimeDefault
        supplementalGroups: []
        sysctls: []
      serviceAccountName: release-name-kafka
      enableServiceLinks: true
      initContainers:
        - name: prepare-config
          image: docker.io/bitnami/kafka:4.0.0-debian-12-r10
          imagePullPolicy: IfNotPresent
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              add: []
              drop:
                - ALL
            privileged: false
            readOnlyRootFilesystem: true
            runAsGroup: 1001
            runAsNonRoot: true
            runAsUser: 1001
            seLinuxOptions: {}
            seccompProfile:
              type: RuntimeDefault
          resources:
            limits:
              cpu: 150m
              ephemeral-storage: 2Gi
              memory: 192Mi
            requests:
              cpu: 100m
              ephemeral-storage: 50Mi
              memory: 128Mi
          command:
            - /bin/bash
          args:
            - -ec
            - |
              . /opt/bitnami/scripts/libkafka.sh
              configure_kafka_sasl() {
                  # Replace placeholders with passwords
                  replace_in_file "$KAFKA_CONF_FILE" "interbroker-password-placeholder" "$KAFKA_INTER_BROKER_PASSWORD"
                  replace_in_file "$KAFKA_CONF_FILE" "controller-password-placeholder" "$KAFKA_CONTROLLER_PASSWORD"
                  read -r -a passwords <<< "$(tr ',;' ' ' <<<"${KAFKA_CLIENT_PASSWORDS:-}")"
                  for ((i = 0; i < ${#passwords[@]}; i++)); do
                      replace_in_file "$KAFKA_CONF_FILE" "password-placeholder-${i}\"" "${passwords[i]}\""
                  done
              }

              cp /configmaps/server.properties $KAFKA_CONF_FILE

              # Get pod ID and role, last and second last fields in the pod name respectively
              POD_ID="${MY_POD_NAME##*-}"
              POD_ROLE="${MY_POD_NAME%-*}"; POD_ROLE="${POD_ROLE##*-}"

              # Configure node.id
              ID=$((POD_ID + KAFKA_MIN_ID))
              [[ -f "/bitnami/kafka/data/meta.properties" ]] && ID="$(grep "node.id" /bitnami/kafka/data/meta.properties | awk -F '=' '{print $2}')"
              kafka_server_conf_set "node.id" "$ID"
              # Configure initial controllers
              if [[ "controller" =~ "$POD_ROLE" ]]; then
                  INITIAL_CONTROLLERS=()
                  for ((i = 0; i < 3; i++)); do
                      var="KAFKA_CONTROLLER_${i}_DIR_ID"; DIR_ID="${!var}"
                      [[ $i -eq $POD_ID ]] && [[ -f "/bitnami/kafka/data/meta.properties" ]] && DIR_ID="$(grep "directory.id" /bitnami/kafka/data/meta.properties | awk -F '=' '{print $2}')"
                      INITIAL_CONTROLLERS+=("${i}@${KAFKA_FULLNAME}-${POD_ROLE}-${i}.${KAFKA_CONTROLLER_SVC_NAME}.${MY_POD_NAMESPACE}.svc.${CLUSTER_DOMAIN}:${KAFKA_CONTROLLER_PORT}:${DIR_ID}")
                  done
                  echo "${INITIAL_CONTROLLERS[*]}" | awk -v OFS=',' '{$1=$1}1' > /shared/initial-controllers.txt
              fi
              replace_in_file "$KAFKA_CONF_FILE" "advertised-address-placeholder" "${MY_POD_NAME}.${KAFKA_FULLNAME}-${POD_ROLE}-headless.${MY_POD_NAMESPACE}.svc.${CLUSTER_DOMAIN}"
              sasl_env_vars=(
                KAFKA_CLIENT_PASSWORDS
                KAFKA_INTER_BROKER_PASSWORD
                KAFKA_INTER_BROKER_CLIENT_SECRET
                KAFKA_CONTROLLER_PASSWORD
                KAFKA_CONTROLLER_CLIENT_SECRET
              )
              for env_var in "${sasl_env_vars[@]}"; do
                  file_env_var="${env_var}_FILE"
                  if [[ -n "${!file_env_var:-}" ]]; then
                      if [[ -r "${!file_env_var:-}" ]]; then
                          export "${env_var}=$(< "${!file_env_var}")"
                          unset "${file_env_var}"
                      else
                          warn "Skipping export of '${env_var}'. '${!file_env_var:-}' is not readable."
                      fi
                  fi
              done
              configure_kafka_sasl
              if [[ -f /secret-config/server-secret.properties ]]; then
                  cat /secret-config/server-secret.properties >> $KAFKA_CONF_FILE
              fi

          env:
            - name: BITNAMI_DEBUG
              value: 'false'
            - name: MY_POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: MY_POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: KAFKA_FULLNAME
              value: 'release-name-kafka'
            - name: CLUSTER_DOMAIN
              value: 'cluster.local'
            - name: KAFKA_VOLUME_DIR
              value: '/bitnami/kafka'
            - name: KAFKA_CONF_FILE
              value: /config/server.properties
            - name: KAFKA_MIN_ID
              value: '0'
            - name: KAFKA_CONTROLLER_SVC_NAME
              value: release-name-kafka-controller-headless
            - name: KAFKA_CONTROLLER_PORT
              value: '9093'
            - name: KAFKA_CONTROLLER_0_DIR_ID
              valueFrom:
                secretKeyRef:
                  name: release-name-kafka-kraft
                  key: controller-0-id
            - name: KAFKA_CONTROLLER_1_DIR_ID
              valueFrom:
                secretKeyRef:
                  name: release-name-kafka-kraft
                  key: controller-1-id
            - name: KAFKA_CONTROLLER_2_DIR_ID
              valueFrom:
                secretKeyRef:
                  name: release-name-kafka-kraft
                  key: controller-2-id

            - name: KAFKA_CLIENT_USERS
              value: 'user1'
            - name: KAFKA_CLIENT_PASSWORDS_FILE
              value: /opt/bitnami/kafka/config/secrets/client-passwords
            - name: KAFKA_INTER_BROKER_USER
              value: 'inter_broker_user'
            - name: KAFKA_INTER_BROKER_PASSWORD_FILE
              value: /opt/bitnami/kafka/config/secrets/inter-broker-password
            - name: KAFKA_CONTROLLER_USER
              value: 'controller_user'
            - name: KAFKA_CONTROLLER_PASSWORD_FILE
              value: /opt/bitnami/kafka/config/secrets/controller-password
          volumeMounts:
            - name: data
              mountPath: /bitnami/kafka
            - name: kafka-config
              mountPath: /config
            - name: kafka-configmaps
              mountPath: /configmaps
            - name: kafka-secret-config
              mountPath: /secret-config
            - name: tmp
              mountPath: /tmp
            - name: init-shared
              mountPath: /shared
            - name: kafka-sasl
              mountPath: /opt/bitnami/kafka/config/secrets
              readOnly: true
      containers:
        - name: kafka
          image: docker.io/bitnami/kafka:4.0.0-debian-12-r10
          imagePullPolicy: 'IfNotPresent'
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            readOnlyRootFilesystem: true
            runAsGroup: 1001
            runAsNonRoot: true
            runAsUser: 1001
            seLinuxOptions: {}
          env:
            - name: KAFKA_HEAP_OPTS
              value: '-XX:InitialRAMPercentage=75 -XX:MaxRAMPercentage=75'
            - name: KAFKA_CFG_PROCESS_ROLES
              value: 'controller,broker'
            - name: KAFKA_INITIAL_CONTROLLERS_FILE
              value: /shared/initial-controllers.txt
            - name: BITNAMI_DEBUG
              value: 'false'
            - name: KAFKA_KRAFT_CLUSTER_ID
              valueFrom:
                secretKeyRef:
                  name: release-name-kafka-kraft
                  key: cluster-id
            - name: KAFKA_KRAFT_BOOTSTRAP_SCRAM_USERS
              value: 'true'

            - name: KAFKA_CLIENT_USERS
              value: 'user1'
            - name: KAFKA_CLIENT_PASSWORDS_FILE
              value: /opt/bitnami/kafka/config/secrets/client-passwords
            - name: KAFKA_INTER_BROKER_USER
              value: 'inter_broker_user'
            - name: KAFKA_INTER_BROKER_PASSWORD_FILE
              value: /opt/bitnami/kafka/config/secrets/inter-broker-password
            - name: KAFKA_CONTROLLER_USER
              value: 'controller_user'
            - name: KAFKA_CONTROLLER_PASSWORD_FILE
              value: /opt/bitnami/kafka/config/secrets/controller-password
          ports:
            - name: controller
              containerPort: 9093
            - name: client
              containerPort: 9092
            - name: interbroker
              containerPort: 9094
          livenessProbe:
            failureThreshold: 3
            initialDelaySeconds: 10
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - pgrep
                - -f
                - kafka
          readinessProbe:
            failureThreshold: 6
            initialDelaySeconds: 5
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            tcpSocket:
              port: 'controller'
          resources:
            limits:
              cpu: 750m
              ephemeral-storage: 2Gi
              memory: 768Mi
            requests:
              cpu: 500m
              ephemeral-storage: 50Mi
              memory: 512Mi
          volumeMounts:
            - name: data
              mountPath: /bitnami/kafka
            - name: logs
              mountPath: /opt/bitnami/kafka/logs
            - name: kafka-config
              mountPath: /opt/bitnami/kafka/config/server.properties
              subPath: server.properties
            - name: tmp
              mountPath: /tmp
            - name: init-shared
              mountPath: /shared
            - name: kafka-sasl
              mountPath: /opt/bitnami/kafka/config/secrets
              readOnly: true
      volumes:
        - name: kafka-configmaps
          configMap:
            name: release-name-kafka-controller-configuration
        - name: kafka-secret-config
          emptyDir: {}
        - name: kafka-config
          emptyDir: {}
        - name: tmp
          emptyDir: {}
        - name: init-shared
          emptyDir: {}
        - name: kafka-sasl
          projected:
            sources:
              - secret:
                  name: release-name-kafka-user-passwords
        - name: logs
          emptyDir: {}
  volumeClaimTemplates:
    - apiVersion: v1
      kind: PersistentVolumeClaim
      metadata:
        name: data
      spec:
        accessModes:
          - 'ReadWriteOnce'
        resources:
          requests:
            storage: '8Gi'
---
# Source: snow-white/charts/postgresql/templates/primary/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: release-name-postgresql-primary
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 17.6.0
    helm.sh/chart: postgresql-16.7.27
    app.kubernetes.io/component: primary
spec:
  replicas: 1
  serviceName: release-name-postgresql-primary-hl
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/component: primary
  template:
    metadata:
      name: release-name-postgresql-primary
      labels:
        app.kubernetes.io/instance: release-name
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: postgresql
        app.kubernetes.io/version: 17.6.0
        helm.sh/chart: postgresql-16.7.27
        app.kubernetes.io/component: primary
    spec:
      serviceAccountName: release-name-postgresql

      automountServiceAccountToken: false
      affinity:
        podAffinity:

        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/instance: release-name
                    app.kubernetes.io/name: postgresql
                    app.kubernetes.io/component: primary
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:

      securityContext:
        fsGroup: 1001
        fsGroupChangePolicy: Always
        supplementalGroups: []
        sysctls: []
      hostNetwork: false
      hostIPC: false
      containers:
        - name: postgresql
          image: docker.io/bitnami/postgresql:17.6.0-debian-12-r4
          imagePullPolicy: 'IfNotPresent'
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            privileged: false
            readOnlyRootFilesystem: true
            runAsGroup: 1001
            runAsNonRoot: true
            runAsUser: 1001
            seLinuxOptions: {}
            seccompProfile:
              type: RuntimeDefault
          env:
            - name: BITNAMI_DEBUG
              value: 'false'
            - name: POSTGRESQL_PORT_NUMBER
              value: '5432'
            - name: POSTGRESQL_VOLUME_DIR
              value: '/bitnami/postgresql'
            - name: PGDATA
              value: '/bitnami/postgresql/data'
            # Authentication
            - name: POSTGRES_PASSWORD_FILE
              value: /opt/bitnami/postgresql/secrets/postgres-password
            # Replication
            - name: POSTGRES_REPLICATION_MODE
              value: 'master'
            - name: POSTGRES_REPLICATION_USER
              value: 'repl_user'
            - name: POSTGRES_REPLICATION_PASSWORD_FILE
              value: /opt/bitnami/postgresql/secrets/replication-password
            - name: POSTGRES_CLUSTER_APP_NAME
              value: my_application
            # LDAP
            - name: POSTGRESQL_ENABLE_LDAP
              value: 'no'
            # TLS
            - name: POSTGRESQL_ENABLE_TLS
              value: 'no'
            # Audit
            - name: POSTGRESQL_LOG_HOSTNAME
              value: 'false'
            - name: POSTGRESQL_LOG_CONNECTIONS
              value: 'false'
            - name: POSTGRESQL_LOG_DISCONNECTIONS
              value: 'false'
            - name: POSTGRESQL_PGAUDIT_LOG_CATALOG
              value: 'off'
            # Others
            - name: POSTGRESQL_CLIENT_MIN_MESSAGES
              value: 'error'
            - name: POSTGRESQL_SHARED_PRELOAD_LIBRARIES
              value: 'pgaudit'
          ports:
            - name: tcp-postgresql
              containerPort: 5432
          livenessProbe:
            failureThreshold: 6
            initialDelaySeconds: 30
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - /bin/sh
                - -c
                - exec pg_isready -U "postgres" -h 127.0.0.1 -p 5432
          readinessProbe:
            failureThreshold: 6
            initialDelaySeconds: 5
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - /bin/sh
                - -c
                - -e
                - |
                  exec pg_isready -U "postgres" -h 127.0.0.1 -p 5432
                  [ -f /opt/bitnami/postgresql/tmp/.initialized ] || [ -f /bitnami/postgresql/.initialized ]
          resources:
            limits:
              cpu: 150m
              ephemeral-storage: 2Gi
              memory: 192Mi
            requests:
              cpu: 100m
              ephemeral-storage: 50Mi
              memory: 128Mi
          volumeMounts:
            - name: empty-dir
              mountPath: /tmp
              subPath: tmp-dir
            - name: empty-dir
              mountPath: /opt/bitnami/postgresql/conf
              subPath: app-conf-dir
            - name: empty-dir
              mountPath: /opt/bitnami/postgresql/tmp
              subPath: app-tmp-dir
            - name: postgresql-password
              mountPath: /opt/bitnami/postgresql/secrets/
            - name: dshm
              mountPath: /dev/shm
            - name: data
              mountPath: /bitnami/postgresql
      volumes:
        - name: empty-dir
          emptyDir: {}
        - name: postgresql-password
          secret:
            secretName: release-name-postgresql
        - name: dshm
          emptyDir:
            medium: Memory
  volumeClaimTemplates:
    - apiVersion: v1
      kind: PersistentVolumeClaim
      metadata:
        name: data
      spec:
        accessModes:
          - 'ReadWriteOnce'
        resources:
          requests:
            storage: '8Gi'
---
# Source: snow-white/charts/postgresql/templates/read/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: release-name-postgresql-read
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/version: 17.6.0
    helm.sh/chart: postgresql-16.7.27
    app.kubernetes.io/component: read
spec:
  replicas: 1
  serviceName: release-name-postgresql-read-hl
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/component: read
  template:
    metadata:
      name: release-name-postgresql-read
      labels:
        app.kubernetes.io/instance: release-name
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: postgresql
        app.kubernetes.io/version: 17.6.0
        helm.sh/chart: postgresql-16.7.27
        app.kubernetes.io/component: read
    spec:
      serviceAccountName: release-name-postgresql

      automountServiceAccountToken: false
      affinity:
        podAffinity:

        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/instance: release-name
                    app.kubernetes.io/name: postgresql
                    app.kubernetes.io/component: read
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:

      securityContext:
        fsGroup: 1001
        fsGroupChangePolicy: Always
        supplementalGroups: []
        sysctls: []
      hostNetwork: false
      hostIPC: false
      containers:
        - name: postgresql
          image: docker.io/bitnami/postgresql:17.6.0-debian-12-r4
          imagePullPolicy: 'IfNotPresent'
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            privileged: false
            readOnlyRootFilesystem: true
            runAsGroup: 1001
            runAsNonRoot: true
            runAsUser: 1001
            seLinuxOptions: {}
            seccompProfile:
              type: RuntimeDefault
          env:
            - name: BITNAMI_DEBUG
              value: 'false'
            - name: POSTGRESQL_PORT_NUMBER
              value: '5432'
            - name: POSTGRESQL_VOLUME_DIR
              value: '/bitnami/postgresql'
            - name: PGDATA
              value: '/bitnami/postgresql/data'
            # Authentication
            - name: POSTGRES_PASSWORD_FILE
              value: /opt/bitnami/postgresql/secrets/postgres-password
            # Replication
            - name: POSTGRES_REPLICATION_MODE
              value: 'slave'
            - name: POSTGRES_REPLICATION_USER
              value: 'repl_user'
            - name: POSTGRES_REPLICATION_PASSWORD_FILE
              value: /opt/bitnami/postgresql/secrets/replication-password
            - name: POSTGRES_CLUSTER_APP_NAME
              value: my_application
            - name: POSTGRES_MASTER_HOST
              value: release-name-postgresql-primary
            - name: POSTGRES_MASTER_PORT_NUMBER
              value: '5432'
            # TLS
            - name: POSTGRESQL_ENABLE_TLS
              value: 'no'
            # Audit
            - name: POSTGRESQL_LOG_HOSTNAME
              value: 'false'
            - name: POSTGRESQL_LOG_CONNECTIONS
              value: 'false'
            - name: POSTGRESQL_LOG_DISCONNECTIONS
              value: 'false'
            - name: POSTGRESQL_PGAUDIT_LOG_CATALOG
              value: 'off'
            # Others
            - name: POSTGRESQL_CLIENT_MIN_MESSAGES
              value: 'error'
            - name: POSTGRESQL_SHARED_PRELOAD_LIBRARIES
              value: 'pgaudit'
          ports:
            - name: tcp-postgresql
              containerPort: 5432
          livenessProbe:
            failureThreshold: 6
            initialDelaySeconds: 30
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - /bin/sh
                - -c
                - exec pg_isready -U "postgres" -h 127.0.0.1 -p 5432
          readinessProbe:
            failureThreshold: 6
            initialDelaySeconds: 5
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - /bin/sh
                - -c
                - -e
                - |
                  exec pg_isready -U "postgres" -h 127.0.0.1 -p 5432
                  [ -f /opt/bitnami/postgresql/tmp/.initialized ] || [ -f /bitnami/postgresql/.initialized ]
          resources:
            limits:
              cpu: 150m
              ephemeral-storage: 2Gi
              memory: 192Mi
            requests:
              cpu: 100m
              ephemeral-storage: 50Mi
              memory: 128Mi
          volumeMounts:
            - name: empty-dir
              mountPath: /tmp
              subPath: tmp-dir
            - name: empty-dir
              mountPath: /opt/bitnami/postgresql/conf
              subPath: app-conf-dir
            - name: empty-dir
              mountPath: /opt/bitnami/postgresql/tmp
              subPath: app-tmp-dir
            - name: postgresql-password
              mountPath: /opt/bitnami/postgresql/secrets/
            - name: dshm
              mountPath: /dev/shm
            - name: data
              mountPath: /bitnami/postgresql
      volumes:
        - name: postgresql-password
          secret:
            secretName: release-name-postgresql
        - name: dshm
          emptyDir:
            medium: Memory
        - name: empty-dir
          emptyDir: {}
  volumeClaimTemplates:
    - apiVersion: v1
      kind: PersistentVolumeClaim
      metadata:
        name: data
      spec:
        accessModes:
          - 'ReadWriteOnce'
        resources:
          requests:
            storage: '8Gi'
---
# Source: snow-white/charts/redis/templates/master/application.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: release-name-redis-master
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis
    app.kubernetes.io/version: 8.2.1
    helm.sh/chart: redis-22.0.7
    app.kubernetes.io/component: master
spec:
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: redis
      app.kubernetes.io/component: master
  serviceName: release-name-redis-headless
  updateStrategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app.kubernetes.io/instance: release-name
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: redis
        app.kubernetes.io/version: 8.2.1
        helm.sh/chart: redis-22.0.7
        app.kubernetes.io/component: master
      annotations:
        checksum/configmap: 2a9ab4a5432825504d910f022638674ce88eaefe9f9f595ad8bc107377d104fb
        checksum/health: aff24913d801436ea469d8d374b2ddb3ec4c43ee7ab24663d5f8ff1a1b6991a9
        checksum/scripts: 29c479262c39be28b26be41c0214372951c12d84747b3ce0c24b68b3c71f4a5b
        checksum/secret: 56e2503f41ce69e264665c1bbda6c6694da59930b441d5923e8aaeee09ece809
    spec:
      securityContext:
        fsGroup: 1001
        fsGroupChangePolicy: Always
        supplementalGroups: []
        sysctls: []
      serviceAccountName: release-name-redis-master
      automountServiceAccountToken: false
      affinity:
        podAffinity:

        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/instance: release-name
                    app.kubernetes.io/name: redis
                    app.kubernetes.io/component: master
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:

      enableServiceLinks: true
      terminationGracePeriodSeconds: 30
      containers:
        - name: redis
          image: docker.io/bitnami/redis:8.2.1-debian-12-r0
          imagePullPolicy: 'IfNotPresent'
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            readOnlyRootFilesystem: true
            runAsGroup: 1001
            runAsNonRoot: true
            runAsUser: 1001
            seLinuxOptions: {}
            seccompProfile:
              type: RuntimeDefault
          command:
            - /bin/bash
          args:
            - -ec
            - /opt/bitnami/scripts/start-scripts/start-master.sh
          env:
            - name: BITNAMI_DEBUG
              value: 'false'
            - name: REDIS_REPLICATION_MODE
              value: master
            - name: ALLOW_EMPTY_PASSWORD
              value: 'no'
            - name: REDIS_PASSWORD_FILE
              value: '/opt/bitnami/redis/secrets/redis-password'
            - name: REDIS_TLS_ENABLED
              value: 'no'
            - name: REDIS_PORT
              value: '6379'
          ports:
            - name: redis
              containerPort: 6379
          livenessProbe:
            initialDelaySeconds: 20
            periodSeconds: 5
            # One second longer than command timeout should prevent generation of zombie processes.
            timeoutSeconds: 6
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - /bin/bash
                - -ec
                - '/health/ping_liveness_local.sh 5'
          readinessProbe:
            initialDelaySeconds: 20
            periodSeconds: 5
            timeoutSeconds: 2
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - /bin/bash
                - -ec
                - '/health/ping_readiness_local.sh 1'
          resources:
            limits:
              cpu: 150m
              ephemeral-storage: 2Gi
              memory: 192Mi
            requests:
              cpu: 100m
              ephemeral-storage: 50Mi
              memory: 128Mi
          volumeMounts:
            - name: start-scripts
              mountPath: /opt/bitnami/scripts/start-scripts
            - name: health
              mountPath: /health
            - name: redis-password
              mountPath: /opt/bitnami/redis/secrets/
            - name: redis-data
              mountPath: /data
            - name: config
              mountPath: /opt/bitnami/redis/mounted-etc
            - name: empty-dir
              mountPath: /opt/bitnami/redis/etc/
              subPath: app-conf-dir
            - name: empty-dir
              mountPath: /tmp
              subPath: tmp-dir
      volumes:
        - name: start-scripts
          configMap:
            name: release-name-redis-scripts
            defaultMode: 0755
        - name: health
          configMap:
            name: release-name-redis-health
            defaultMode: 0755
        - name: redis-password

          secret:
            secretName: release-name-redis
            items:
              - key: redis-password
                path: redis-password
        - name: config
          configMap:
            name: release-name-redis-configuration
        - name: empty-dir
          emptyDir: {}
  volumeClaimTemplates:
    - apiVersion: v1
      kind: PersistentVolumeClaim
      metadata:
        name: redis-data
        labels:
          app.kubernetes.io/instance: release-name
          app.kubernetes.io/name: redis
          app.kubernetes.io/component: master
      spec:
        accessModes:
          - 'ReadWriteOnce'
        resources:
          requests:
            storage: '8Gi'
---
# Source: snow-white/charts/redis/templates/replicas/application.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: release-name-redis-replicas
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis
    app.kubernetes.io/version: 8.2.1
    helm.sh/chart: redis-22.0.7
    app.kubernetes.io/component: replica
spec:
  replicas: 3
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/name: redis
      app.kubernetes.io/component: replica
  serviceName: release-name-redis-headless
  updateStrategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app.kubernetes.io/instance: release-name
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: redis
        app.kubernetes.io/version: 8.2.1
        helm.sh/chart: redis-22.0.7
        app.kubernetes.io/component: replica
      annotations:
        checksum/configmap: 2a9ab4a5432825504d910f022638674ce88eaefe9f9f595ad8bc107377d104fb
        checksum/health: aff24913d801436ea469d8d374b2ddb3ec4c43ee7ab24663d5f8ff1a1b6991a9
        checksum/scripts: 29c479262c39be28b26be41c0214372951c12d84747b3ce0c24b68b3c71f4a5b
        checksum/secret: 6b31318d39c9a557322cd60d87bb80cff602c8e65b66cf74e20709df20974a4a
    spec:
      securityContext:
        fsGroup: 1001
        fsGroupChangePolicy: Always
        supplementalGroups: []
        sysctls: []
      serviceAccountName: release-name-redis-replica
      automountServiceAccountToken: false
      affinity:
        podAffinity:

        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/instance: release-name
                    app.kubernetes.io/name: redis
                    app.kubernetes.io/component: replica
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:

      enableServiceLinks: true
      terminationGracePeriodSeconds: 30
      containers:
        - name: redis
          image: docker.io/bitnami/redis:8.2.1-debian-12-r0
          imagePullPolicy: 'IfNotPresent'
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            readOnlyRootFilesystem: true
            runAsGroup: 1001
            runAsNonRoot: true
            runAsUser: 1001
            seLinuxOptions: {}
            seccompProfile:
              type: RuntimeDefault
          command:
            - /bin/bash
          args:
            - -ec
            - /opt/bitnami/scripts/start-scripts/start-replica.sh
          env:
            - name: BITNAMI_DEBUG
              value: 'false'
            - name: REDIS_REPLICATION_MODE
              value: replica
            - name: REDIS_MASTER_HOST
              value: release-name-redis-master-0.release-name-redis-headless.snow-white.svc.cluster.local
            - name: REDIS_MASTER_PORT_NUMBER
              value: '6379'
            - name: ALLOW_EMPTY_PASSWORD
              value: 'no'
            - name: REDIS_PASSWORD_FILE
              value: '/opt/bitnami/redis/secrets/redis-password'
            - name: REDIS_MASTER_PASSWORD_FILE
              value: '/opt/bitnami/redis/secrets/redis-password'
            - name: REDIS_TLS_ENABLED
              value: 'no'
            - name: REDIS_PORT
              value: '6379'
          ports:
            - name: redis
              containerPort: 6379
          startupProbe:
            failureThreshold: 22
            initialDelaySeconds: 10
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            tcpSocket:
              port: redis
          livenessProbe:
            initialDelaySeconds: 20
            periodSeconds: 5
            timeoutSeconds: 6
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - /bin/bash
                - -ec
                - '/health/ping_liveness_local_and_master.sh 5'
          readinessProbe:
            initialDelaySeconds: 20
            periodSeconds: 5
            timeoutSeconds: 2
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - /bin/bash
                - -ec
                - '/health/ping_readiness_local_and_master.sh 1'
          resources:
            limits:
              cpu: 150m
              ephemeral-storage: 2Gi
              memory: 192Mi
            requests:
              cpu: 100m
              ephemeral-storage: 50Mi
              memory: 128Mi
          volumeMounts:
            - name: start-scripts
              mountPath: /opt/bitnami/scripts/start-scripts
            - name: health
              mountPath: /health
            - name: redis-password
              mountPath: /opt/bitnami/redis/secrets/
            - name: redis-data
              mountPath: /data
            - name: config
              mountPath: /opt/bitnami/redis/mounted-etc
            - name: empty-dir
              mountPath: /opt/bitnami/redis/etc
              subPath: app-conf-dir
            - name: empty-dir
              mountPath: /tmp
              subPath: tmp-dir
      volumes:
        - name: start-scripts
          configMap:
            name: release-name-redis-scripts
            defaultMode: 0755
        - name: health
          configMap:
            name: release-name-redis-health
            defaultMode: 0755
        - name: redis-password

          secret:
            secretName: release-name-redis
            items:
              - key: redis-password
                path: redis-password
        - name: config
          configMap:
            name: release-name-redis-configuration
        - name: empty-dir
          emptyDir: {}
  volumeClaimTemplates:
    - apiVersion: v1
      kind: PersistentVolumeClaim
      metadata:
        name: redis-data
        labels:
          app.kubernetes.io/instance: release-name
          app.kubernetes.io/name: redis
          app.kubernetes.io/component: replica
      spec:
        accessModes:
          - 'ReadWriteOnce'
        resources:
          requests:
            storage: '8Gi'
---
# Source: snow-white/templates/api-gateway.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: snow-white-release-name
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/version: v1.0.0-ci.0
    helm.sh/chart: snow-white
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/name: api-gateway
    app.kubernetes.io/part-of: snow-white
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        -
  rules:
    - host:
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: snow-white-release-name-api-gateway
                port:
                  name: http
---
# Source: snow-white/charts/influxdb/templates/pvc.yaml
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: release-name-influxdb
  namespace: 'snow-white'
  labels:
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: influxdb
    app.kubernetes.io/version: 3.4.1
    helm.sh/chart: influxdb-7.1.20
    app.kubernetes.io/part-of: influxdb
    app.kubernetes.io/component: influxdb
  annotations:
    helm.sh/hook: pre-install
spec:
  accessModes:
    - 'ReadWriteOnce'
  resources:
    requests:
      storage: '8Gi'
